/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthorizedHttpClient = exports.HttpClient = void 0;
const error_1 = require("./error");
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const url_1 = require("url");
const util_1 = require("util");
const querystring_1 = require("querystring");
const apminsight_1 = __importDefault(require("../../lib/apminsight"));
const constants_1 = __importDefault(require("./constants"));
const request_agent_1 = __importDefault(require("./request-agent"));
const credential_1 = require("./credential");
const package_json_1 = require("../../package.json");
const { PROJECT_KEY_NAME, IS_LOCAL, ENVIRONMENT_KEY_NAME, USER_KEY_NAME, CREDENTIAL_USER, CATALYST_ORIGIN, PRODUCT_NAME, API_VERSION, USER_AGENT, APM_INSIGHT, ACCEPT_HEADER } = constants_1.default;
class DefaultHttpResponse {
    constructor(resp) {
        this.statusCode = resp.statusCode;
        this.headers = resp.headers;
        this.text = resp.data;
        this.buffer = resp.buffer;
        try {
            this.parsedData = JSON.parse(resp.data);
        }
        catch (err) {
            this.parsedData = undefined;
            this.parseError = err;
        }
    }
    get data() {
        if (typeof this.parsedData !== 'undefined') {
            return this.parsedData;
        }
        if (this.text === '') {
            throw new error_1.CatalystApiError('empty_response', 'Empty response recevied from server. Raw server ' +
                `response: "${this.text}". Status code: "${this.statusCode}".`);
        }
        throw new error_1.CatalystApiError('unparsable_response', `Error while parsing response data: "${this.parseError.toString()}". Raw server ` +
            `response: "${this.text}". Status code: "${this.statusCode}".`);
    }
}
function _finalizeRequest(resolve, reject, response) {
    if (response.statusCode === undefined) {
        reject(new error_1.CatalystApiError('unknown_statusCode', 'unable to obtain status code from response', response));
        return;
    }
    if (response.statusCode >= 200 && response.statusCode < 300) {
        resolve(response);
    }
    else {
        try {
            // catalyst error
            reject('Request failed with status ' +
                response.statusCode +
                ' and code : ' +
                JSON.parse(response.data).data.error_code +
                ' , message : ' +
                JSON.parse(response.data).data.message);
        }
        catch (e) {
            // unknown error
            reject('Request failed with status ' +
                response.statusCode +
                ' and response data : ' +
                (0, util_1.inspect)(response.data));
        }
    }
}
function _appendQueryData(url, data) {
    if (data && Object.keys(data).length > 0) {
        url += url.includes('?') ? '&' : '?';
        url += (0, querystring_1.stringify)(data);
    }
    return url;
}
function _request(transport, options, data, config) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const req = transport.request(options, (res) => {
                if (req.aborted) {
                    return;
                }
                // Uncompress the response body transparently if required.
                const response = Object.assign({
                    headers: res.headers,
                    request: req,
                    config
                }, res);
                const responseBuffer = [];
                res.on('data', (chunk) => {
                    responseBuffer.push(chunk);
                });
                res.on('error', (err) => {
                    if (req.aborted) {
                        return;
                    }
                    reject(err);
                });
                res.on('end', () => {
                    const responseData = Buffer.concat(responseBuffer);
                    response.data = responseData.toString();
                    response.buffer = responseData;
                    _finalizeRequest(resolve, reject, response);
                });
            });
            // Handle errors
            req.on('error', (err) => {
                if (req.aborted) {
                    return;
                }
                reject(err);
            });
            // Send the request
            if (data !== undefined) {
                if (config.type === 'file') {
                    config.data.pipe(req).on('finish', () => {
                        req.end();
                    });
                }
                else {
                    req.write(data);
                    req.end();
                }
            }
            else {
                req.end();
            }
        });
    });
}
function sendRequest(config) {
    return __awaiter(this, void 0, void 0, function* () {
        let data;
        let headers = Object.assign({
            [USER_AGENT.KEY]: USER_AGENT.PREFIX + package_json_1.version
        }, config.headers);
        if (config.data !== undefined) {
            switch (config.type) {
                case 'json':
                    data = JSON.stringify(config.data);
                    headers['Content-Type'] = 'application/json';
                    break;
                case 'file':
                    data = config.data;
                    headers = data.getHeaders(headers);
                    break;
                default:
                    data = (0, querystring_1.stringify)(config.data);
                    headers['Content-Type'] = 'application/x-www-form-urlencoded';
                    headers['Content-Length'] = Buffer.byteLength(data) + '';
            }
        }
        const origin = config.origin || CATALYST_ORIGIN;
        config.url = config.url || new url_1.URL(config.path || '', origin).href;
        if (config.qs !== undefined) {
            config.url = _appendQueryData(config.url, config.qs);
        }
        const parsed = (0, url_1.parse)(config.url);
        if (parsed.hostname === null) {
            throw new error_1.CatalystApiError('unparsable_config', 'Hostname cannot be null', config.path);
        }
        const protocol = parsed.protocol || 'https:';
        const isHttps = protocol === 'https:';
        const transport = isHttps ? https_1.default : http_1.default;
        const agent = new request_agent_1.default(protocol, parsed.hostname, false).agent;
        const options = {
            hostname: parsed.hostname,
            port: parsed.port,
            path: parsed.path,
            method: config.method,
            headers,
            agent
        };
        return _request(transport, options, data, config);
    });
}
class HttpClient {
    /**
     * @param {CatalystApp} app The app used to fetch access tokens to sign API requests.
     * @constructor
     */
    constructor(app) {
        this.app = app;
        this.user = CREDENTIAL_USER.admin;
    }
    send(req, apmTrackerName) {
        return __awaiter(this, void 0, void 0, function* () {
            req.headers = Object.assign({}, req.headers);
            if (this.app !== undefined) {
                if (typeof req.user === 'string') {
                    this.app.switchUser(req.user);
                }
                req.headers[PROJECT_KEY_NAME] = this.app.config.projectKey;
                req.headers[ENVIRONMENT_KEY_NAME] = this.app.config.environment;
                if (this.app.credential instanceof credential_1.CatalystCredential) {
                    this.user = this.app.credential.getCurrentUser();
                }
                // assign user headers
                req.headers[USER_KEY_NAME] = this.user;
                // spcl handling for CLI
                if (IS_LOCAL === 'true') {
                    switch (this.user) {
                        case CREDENTIAL_USER.admin:
                            req.origin =
                                'https://' +
                                    CATALYST_ORIGIN.replace('https://', '').replace('http://', '');
                            break;
                        case CREDENTIAL_USER.user:
                            req.origin = 'https://' + this.app.config.projectDomain;
                            break;
                    }
                }
                // format the path if needed (not undefined and true)
                if (req.catalyst) {
                    req.path =
                        `/${PRODUCT_NAME}/${API_VERSION}/project/${this.app.config.projectId}` +
                            req.path;
                    req.headers[ACCEPT_HEADER.KEY] = ACCEPT_HEADER.VALUE;
                }
            }
            try {
                let resp;
                if (req.track && apmTrackerName) {
                    resp = yield apminsight_1.default.startTracker(APM_INSIGHT.tracker_name, apmTrackerName, () => sendRequest(req));
                }
                else {
                    resp = yield sendRequest(req);
                }
                return new DefaultHttpResponse(resp);
            }
            catch (err) {
                if (err instanceof Error) {
                    throw new error_1.CatalystApiError('request_failure', err.message, err);
                }
                throw err;
            }
        });
    }
}
exports.HttpClient = HttpClient;
class AuthorizedHttpClient extends HttpClient {
    /**
     * @param {any} app The app used to fetch access tokens to sign API requests.
     * @constructor
     */
    constructor(app, component) {
        super(app);
        this.app = app;
        if (component) {
            this.componentName = component.getComponentName();
        }
    }
    send(request) {
        const _super = Object.create(null, {
            send: { get: () => super.send }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const requestCopy = Object.assign({ user: CREDENTIAL_USER.admin }, request);
            requestCopy.headers = Object.assign({}, request.headers);
            yield this.app.authenticateRequest(requestCopy);
            return _super.send.call(this, requestCopy, this.componentName);
        });
    }
}
exports.AuthorizedHttpClient = AuthorizedHttpClient;
